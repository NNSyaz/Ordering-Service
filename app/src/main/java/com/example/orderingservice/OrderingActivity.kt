package com.example.orderingservice

import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.webkit.JavascriptInterface
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.appcompat.app.AppCompatActivity
import com.example.orderingservice.databinding.ActivityOrderingBinding
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.robotemi.sdk.Robot
import com.robotemi.sdk.TtsRequest
import java.util.*

class OrderingActivity : AppCompatActivity(), Robot.TtsListener {

    private lateinit var binding: ActivityOrderingBinding
    private lateinit var robot: Robot
    private lateinit var tableStatusManager: TableStatusManager
    private val gson = Gson()

    private var sessionId: String = ""
    private var orderType: String = ""
    private var tableNo: String = ""
    private var currentBattery: Int = 100
    private var orderNumber: String = ""

    // Store customer's actual order data
    private var customerOrderItems: List<String> = emptyList()
    private var orderTotal: String = "0.00"
    private var hasReceivedOrder: Boolean = false

    // Speech management
    private var isSpeaking = false
    private var pendingOrderCompletion = false

    // Inactivity timeout management
    private val inactivityHandler = Handler(Looper.getMainLooper())
    private var lastInteractionTime = System.currentTimeMillis()
    private var inactivityTimeoutRunnable: Runnable? = null

    // Customer choice tracking
    private var hasCustomerMadeChoice = false
    private var customerChoseQR = false

    // QR code display
    private var qrDisplayHandler = Handler(Looper.getMainLooper())

    companion object {
        private const val INACTIVITY_TIMEOUT = 60000L // 1 minute of no interaction
        private const val INACTIVITY_CHECK_INTERVAL = 10000L // Check every 10 seconds
        private const val QR_DISPLAY_TIMEOUT = 60000L // 1 minute for QR code display
        private const val TAG = "OrderingActivity"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityOrderingBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Get data from previous activity
        sessionId = intent.getStringExtra("SESSION_ID") ?: ""
        orderType = intent.getStringExtra("ORDER_TYPE") ?: ""
        tableNo = intent.getStringExtra("TABLE_NO") ?: ""
        currentBattery = intent.getIntExtra("BATTERY", 100)

        // Order number will be generated by the server when order is placed
        orderNumber = "Pending"

        setupUI()
        initializeTemi()
        initializeTableStatusManager()
        setupBackPressedHandler()

        // Start with ordering choice instead of immediately loading menu
        showOrderingChoice()
    }

    private fun setupBackPressedHandler() {
        // Modern way to handle back press
        onBackPressedDispatcher.addCallback(this, object : androidx.activity.OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                if (!isSpeaking) {
                    handleBackPressed()
                }
            }
        })
    }

    private fun setupUI() {
        binding.apply {
            tvTitle.text = "$orderType - $tableNo"
            tvOrderNumber.text = "Order #$orderNumber"
            tvBattery.text = "Battery: ${currentBattery}%"

            btnBack.setOnClickListener {
                if (!isSpeaking) {
                    handleBackPressed()
                }
            }

            // Initially hide all ordering-related elements using new layout IDs
            layoutChoiceButtons.visibility = android.view.View.GONE
            completeOrderContainer.visibility = android.view.View.GONE
            webViewContainer.visibility = android.view.View.GONE
            layoutQrCode.visibility = android.view.View.GONE

            // Setup click listeners for choice buttons
            btnUseQr.setOnClickListener {
                if (!isSpeaking) {
                    customerChooseQR()
                }
            }

            btnUseTemiMenu.setOnClickListener {
                if (!isSpeaking) {
                    customerChooseMenu()
                }
            }

            btnNoOrder.setOnClickListener {
                if (!isSpeaking) {
                    customerChooseNoOrder()
                }
            }

            btnCompleteOrder.setOnClickListener {
                if (!isSpeaking) {
                    completeOrder()
                }
            }
        }
    }

    private fun initializeTemi() {
        robot = Robot.getInstance()
    }

    private fun initializeTableStatusManager() {
        tableStatusManager = TableStatusManager.getInstance()
    }

    override fun onStart() {
        super.onStart()
        robot.addTtsListener(this)
    }

    override fun onStop() {
        super.onStop()
        robot.removeTtsListener(this)
        stopInactivityTimer()
        stopQRDisplayTimer()
    }

    private fun showOrderingChoice() {
        // Reset interaction timer
        resetInactivityTimer()

        // SHORTENED DIALOG: Reduced from 3 sentences to 1 concise sentence
        val choiceMessage = "Please choose"

        speakAndWait(choiceMessage) {
            // Show the enhanced choice interface
            runOnUiThread {
                binding.apply {
                    layoutChoiceButtons.visibility = android.view.View.VISIBLE
                }
            }

            // Start inactivity monitoring
            startInactivityMonitoring()
        }
    }

    private fun customerChooseQR() {
        hasCustomerMadeChoice = true
        customerChoseQR = true
        stopInactivityTimer()

        // SHORTENED DIALOG: Reduced verbosity
        if (orderType.equals("Takeaway", ignoreCase = true)) {
            speakAndWait("Great! Here's your QR code. I'll wait one minute, then return to base.") {
                showQRCodeForTakeaway()
            }
        } else {
            speakAndWait("Perfect! Use the QR code on your table. I'll return to base now. Enjoy!") {
                // For dine-in, just return to base but keep table occupied
                returnToBase(releaseTable = false)
            }
        }
    }

    private fun showQRCodeForTakeaway() {
        runOnUiThread {
            binding.apply {
                // Hide choice buttons and other elements using new IDs
                layoutChoiceButtons.visibility = android.view.View.GONE
                completeOrderContainer.visibility = android.view.View.GONE
                webViewContainer.visibility = android.view.View.GONE

                // Show QR code layout
                layoutQrCode.visibility = android.view.View.VISIBLE

                // Update texts
                tvQrTitle.text = "Scan QR Code to Order"
                tvQrOrderNumber.text = "Use QR Code to Order"
                tvQrInstructions.text = "Scan this QR code with your phone to access our menu and place your order."

                // Load QR code image from drawable
                try {
                    imgQrCode.setImageResource(R.drawable.qr_code_menu) // Replace with your QR code image name
                } catch (e: Exception) {
                    Log.w(TAG, "QR code image not found, showing placeholder")
                    imgQrCode.setImageResource(android.R.drawable.ic_menu_gallery)
                }
            }
        }

        // Send webhook to record QR code usage
        WebhookManager.sendOrderWebhook(
            sessionId = sessionId,
            tableNo = tableNo,
            orderType = orderType,
            menuItems = listOf("QR_CODE_SELECTED"),
            battery = currentBattery,
            orderNumber = "QR",
            customerName = "Guest",
            totalAmount = "0.00",
            onSuccess = { serverOrderNumber ->
                if (serverOrderNumber != null) {
                    orderNumber = serverOrderNumber
                    runOnUiThread {
                        binding.tvQrOrderNumber.text = "Order #$orderNumber"
                    }
                    Log.d(TAG, "QR code selection recorded with order number: $orderNumber")
                } else {
                    Log.d(TAG, "QR code selection recorded successfully")
                }
            },
            onError = { error ->
                Log.e(TAG, "Failed to record QR code selection: $error")
            }
        )

        // Start countdown to return to base
        startQRDisplayTimer()
    }
    private fun startQRDisplayTimer() {
        stopQRDisplayTimer() // Stop any existing timer

        qrDisplayHandler.postDelayed({
            val finalOrderNumber = if (orderNumber != "Pending") orderNumber else "your mobile order"
            // SHORTENED DIALOG: Reduced verbosity
            speakAndWait("Time's up! Returning to base. Use $finalOrderNumber when ordering!") {
                returnToBase(releaseTable = true) // Release table for takeaway
            }
        }, QR_DISPLAY_TIMEOUT)

        Log.d(TAG, "Started QR display timer for $QR_DISPLAY_TIMEOUT ms")
    }

    private fun stopQRDisplayTimer() {
        qrDisplayHandler.removeCallbacksAndMessages(null)
        Log.d(TAG, "Stopped QR display timer")
    }

    private fun customerChooseNoOrder() {
        hasCustomerMadeChoice = true
        stopInactivityTimer()

        // SHORTENED DIALOG: Much more concise
        speakAndWait("No problem! Thank you for visiting. Have a great day!") {
            // Always release table if customer chooses not to order
            releaseTableAndReturn()
        }
    }

    private fun customerChooseMenu() {
        hasCustomerMadeChoice = true
        customerChoseQR = false
        stopInactivityTimer()

        // SHORTENED DIALOG: Reduced from long explanation to concise message
        speakAndWait("Great! Loading our menu now.") {
            // CRITICAL FIX: Show WebView container and hide other elements PROPERLY
            runOnUiThread {
                binding.apply {
                    // Step 1: Hide ALL other layouts COMPLETELY
                    layoutChoiceButtons.visibility = android.view.View.GONE
                    layoutQrCode.visibility = android.view.View.GONE
                    completeOrderContainer.visibility = android.view.View.GONE

                    // Step 2: Show the WebView container
                    webViewContainer.visibility = android.view.View.VISIBLE
                    webViewLoadingIndicator.visibility = android.view.View.VISIBLE

                    // Step 3: Ensure WebView is also visible
                    webView.visibility = android.view.View.VISIBLE

                    Log.d(TAG, "✅ WebView container and WebView visibility set to VISIBLE")
                    Log.d(TAG, "✅ Other layouts hidden: choice=${layoutChoiceButtons.visibility}, qr=${layoutQrCode.visibility}")
                }
            }

            // Load the menu after UI update with a proper delay
            Handler(Looper.getMainLooper()).postDelayed({
                loadMenu()
            }, 500) // Increased delay to ensure UI is fully updated
        }

        startInactivityMonitoring() // Resume monitoring while using menu
    }


    private fun startInactivityMonitoring() {
        stopInactivityTimer() // Stop any existing timer

        lastInteractionTime = System.currentTimeMillis()

        inactivityTimeoutRunnable = object : Runnable {
            override fun run() {
                val currentTime = System.currentTimeMillis()
                val timeSinceLastInteraction = currentTime - lastInteractionTime

                if (timeSinceLastInteraction >= INACTIVITY_TIMEOUT) {
                    handleInactivityTimeout()
                } else {
                    // Check again after interval
                    inactivityHandler.postDelayed(this, INACTIVITY_CHECK_INTERVAL)
                }
            }
        }

        inactivityHandler.postDelayed(inactivityTimeoutRunnable!!, INACTIVITY_CHECK_INTERVAL)
        Log.d(TAG, "Started inactivity monitoring")
    }

    private fun stopInactivityTimer() {
        inactivityTimeoutRunnable?.let {
            inactivityHandler.removeCallbacks(it)
            inactivityTimeoutRunnable = null
        }
        Log.d(TAG, "Stopped inactivity timer")
    }

    private fun resetInactivityTimer() {
        lastInteractionTime = System.currentTimeMillis()
        Log.d(TAG, "Reset inactivity timer")
    }

    private fun handleInactivityTimeout() {
        if (hasCustomerMadeChoice && customerChoseQR) {
            // If customer chose QR, we should have already left
            return
        }

        Log.d(TAG, "Handling inactivity timeout")
        stopInactivityTimer()

        if (!hasCustomerMadeChoice) {
            // SHORTENED DIALOG: Much more concise timeout message
            speakAndWait("No selection made. Returning to base for other customers.") {
                releaseTableAndReturn()
            }
        } else if (!hasReceivedOrder && !customerChoseQR) {
            // SHORTENED DIALOG: Concise inactive message
            speakAndWait("No activity detected. Returning to base. Call me back anytime!") {
                releaseTableAndReturn()
            }
        }
    }

    private fun releaseTableAndReturn() {
        // Release the table
        tableStatusManager.releaseTable(
            sessionId = sessionId,
            tableId = tableNo,
            onSuccess = {
                Log.d(TAG, "Table $tableNo released successfully")
            },
            onError = { error ->
                Log.e(TAG, "Failed to release table: $error")
            }
        )

        returnToBase(releaseTable = true)
    }

    private fun returnToBase(releaseTable: Boolean = false) {
        // Return to standby position
        robot.goTo(Constants.HOME_BASE_LOCATION)

        // Finish activity after delay
        Handler(Looper.getMainLooper()).postDelayed({
            finish()
        }, 2000)
    }

    // Implement Robot.TtsListener
    override fun onTtsStatusChanged(ttsRequest: TtsRequest) {
        Log.d(TAG, "TTS Status changed: ${ttsRequest.status} for message: ${ttsRequest.speech}")

        when (ttsRequest.status) {
            TtsRequest.Status.STARTED -> {
                isSpeaking = true
            }
            TtsRequest.Status.COMPLETED,
            TtsRequest.Status.CANCELED,
            TtsRequest.Status.ERROR -> {
                isSpeaking = false

                // Handle pending order completion
                if (pendingOrderCompletion) {
                    pendingOrderCompletion = false
                    Handler(Looper.getMainLooper()).postDelayed({
                        proceedWithOrderCompletion()
                    }, 500)
                }
            }
            TtsRequest.Status.PENDING -> {
                Log.d(TAG, "TTS is pending")
            }
            TtsRequest.Status.PROCESSING -> {
                Log.d(TAG, "TTS is processing")
                isSpeaking = true
            }
            TtsRequest.Status.NOT_ALLOWED -> {
                Log.w(TAG, "TTS not allowed")
                isSpeaking = false

                // Handle pending order completion even when TTS not allowed
                if (pendingOrderCompletion) {
                    pendingOrderCompletion = false
                    Handler(Looper.getMainLooper()).postDelayed({
                        proceedWithOrderCompletion()
                    }, 500)
                }
            }
        }
    }

    private fun speakAndWait(message: String, onComplete: (() -> Unit)? = null) {
        Log.d(TAG, "Speaking: $message")
        isSpeaking = true

        val ttsRequest = TtsRequest.create(message, false)
        robot.speak(ttsRequest)

        onComplete?.let { callback ->
            val checkCompletion = object : Runnable {
                override fun run() {
                    if (!isSpeaking) {
                        callback.invoke()
                    } else {
                        Handler(Looper.getMainLooper()).postDelayed(this, 100)
                    }
                }
            }
            Handler(Looper.getMainLooper()).postDelayed(checkCompletion, 100)
        }
    }

    private fun loadMenu() {
        binding.webView.apply {
            webViewClient = object : WebViewClient() {
                override fun onPageFinished(view: WebView?, url: String?) {
                    super.onPageFinished(view, url)
                    Log.d(TAG, "Menu loaded successfully")
                    resetInactivityTimer() // Reset timer when menu loads
                }
            }

            settings.javaScriptEnabled = true
            settings.domStorageEnabled = true
            settings.allowFileAccess = true
            settings.allowContentAccess = true

            // Add JavaScript interface to receive order data from the menu
            addJavascriptInterface(WebAppInterface(), "Android")

            // Load your GitHub Pages menu with parameters (no order number yet)
            val menuUrl = "${Constants.MENU_BASE_URL}?t=${tableNo}&session=${sessionId}&orderType=${orderType}"
            Log.d(TAG, "Loading menu: $menuUrl")
            loadUrl(menuUrl)
        }

        // Speak menu introduction
        Handler(Looper.getMainLooper()).postDelayed({
            speakAndWait("Here's our interactive menu. Take your time to browse and tap on items to add them to your order.") {
                Log.d(TAG, "Menu introduction completed")
            }
        }, 1000)
    }

    // JavaScript Interface to receive data from the web menu
    inner class WebAppInterface {

        @JavascriptInterface
        fun onOrderComplete(orderData: String) {
            Log.d(TAG, "Received order data: $orderData")
            resetInactivityTimer() // Reset timer on order interaction

            runOnUiThread {
                try {
                    // Parse the JSON data from the menu
                    val orderJson = gson.fromJson(orderData, JsonObject::class.java)

                    // Extract order information
                    val items = orderJson.getAsJsonArray("items")
                    customerOrderItems = items?.map { it.asString } ?: emptyList()
                    orderTotal = orderJson.get("total")?.asString ?: "0.00"
                    hasReceivedOrder = true

                    Log.d(TAG, "Parsed items: $customerOrderItems")
                    Log.d(TAG, "Total: RM $orderTotal")

                    // Validate order
                    if (customerOrderItems.isEmpty()) {
                        speakAndWait("It looks like you haven't selected any items yet. Please add some items to your order first.") {
                            // Return to menu
                        }
                        return@runOnUiThread
                    }

                    // Send webhook with real customer data - server will generate order number
                    WebhookManager.sendOrderWebhook(
                        sessionId = sessionId,
                        tableNo = tableNo,
                        orderType = orderType,
                        menuItems = customerOrderItems,
                        battery = currentBattery,
                        orderNumber = "MENU_ORDER", // Placeholder - server will generate actual number
                        customerName = "Guest",
                        totalAmount = orderTotal,
                        onSuccess = { serverOrderNumber ->
                            // Server returns the actual order number
                            if (serverOrderNumber != null) {
                                orderNumber = serverOrderNumber
                                runOnUiThread {
                                    binding.tvOrderNumber.text = "Order #$orderNumber"
                                }
                                Log.d(TAG, "Order webhook sent successfully with order number: $orderNumber")
                            } else {
                                Log.d(TAG, "Order webhook sent successfully")
                            }
                        },
                        onError = { error ->
                            Log.e(TAG, "Failed to send webhook: $error")
                        }
                    )

                    // Show order confirmation
                    if (!isSpeaking) {
                        showOrderConfirmation()
                    } else {
                        pendingOrderCompletion = true
                    }

                } catch (e: Exception) {
                    Log.e(TAG, "Error processing order data", e)
                    // Fallback: still complete the order but with generic message
                    customerOrderItems = listOf("Custom Order from Menu")
                    orderTotal = "0.00"
                    hasReceivedOrder = true

                    // Send fallback webhook
                    WebhookManager.sendOrderWebhook(
                        sessionId = sessionId,
                        tableNo = tableNo,
                        orderType = orderType,
                        menuItems = customerOrderItems,
                        battery = currentBattery,
                        orderNumber = "FALLBACK_ORDER",
                        customerName = "Guest",
                        totalAmount = orderTotal,
                        onSuccess = { serverOrderNumber ->
                            if (serverOrderNumber != null) {
                                orderNumber = serverOrderNumber
                                runOnUiThread {
                                    binding.tvOrderNumber.text = "Order #$orderNumber"
                                }
                            }
                        },
                        onError = { error ->
                            Log.e(TAG, "Failed to send fallback webhook: $error")
                        }
                    )

                    if (!isSpeaking) {
                        showOrderConfirmation()
                    } else {
                        pendingOrderCompletion = true
                    }
                }
            }
        }

        @JavascriptInterface
        fun onOrderUpdated(orderData: String) {
            Log.d(TAG, "Order updated: $orderData")
            resetInactivityTimer() // Reset timer on order updates
        }

        @JavascriptInterface
        fun onOrderCancelled() {
            Log.d(TAG, "Order cancelled by customer")
            resetInactivityTimer() // Reset timer on order cancellation
            runOnUiThread {
                speakAndWait("No problem! Your order has been cancelled. Feel free to browse the menu again and add items when you're ready.") {
                    // Reset state
                    hasReceivedOrder = false
                    customerOrderItems = emptyList()
                    orderTotal = "0.00"
                }
            }
        }

        @JavascriptInterface
        fun onMenuReady() {
            Log.d(TAG, "Menu is ready for interaction")
            resetInactivityTimer() // Reset timer when menu becomes ready
        }

        @JavascriptInterface
        fun logMessage(message: String) {
            Log.d("MenuWebView", message)
        }

        @JavascriptInterface
        fun requestHelp(helpType: String) {
            Log.d(TAG, "Customer requested help: $helpType")
            resetInactivityTimer() // Reset timer on help requests
            runOnUiThread {
                val helpMessage = when (helpType.lowercase()) {
                    "navigation" -> "To navigate the menu, simply tap on the categories at the top, then tap on any item to see details and add it to your order."
                    "ordering" -> "To place an order, tap on items to add them to your cart. When you're ready, tap the 'Complete Order' button."
                    "payment" -> "Payment will be handled at the counter after your order is prepared. We accept cash and card payments."
                    else -> "I'm here to help! You can browse the menu by tapping on categories and items. When ready, tap 'Complete Order' to send your order to the kitchen."
                }
                speakAndWait(helpMessage) {}
            }
        }

        @JavascriptInterface
        fun onUserInteraction() {
            // Called whenever user interacts with the menu
            resetInactivityTimer()
        }
    }

    private fun showOrderConfirmation() {
        stopInactivityTimer() // Stop monitoring once order is confirmed

        val itemsText = if (customerOrderItems.isNotEmpty()) {
            customerOrderItems.joinToString(", ")
        } else {
            "Your selected items"
        }

        // SHORTENED DIALOG: Much more concise confirmation message
        val confirmationMessage = when {
            orderNumber == "Pending" -> {
                "Order sent to kitchen! You'll get an order number soon."
            }
            customerOrderItems.isEmpty() -> {
                "Order $orderNumber sent to kitchen!"
            }
            customerOrderItems.size <= 3 -> {
                "Order $orderNumber for $itemsText, RM $orderTotal, sent to kitchen!"
            }
            else -> {
                "Order $orderNumber with ${customerOrderItems.size} items, RM $orderTotal, sent to kitchen!"
            }
        }

        speakAndWait(confirmationMessage) {
            updateUIForOrderComplete(itemsText)

            // Start return sequence after shorter delay
            Handler(Looper.getMainLooper()).postDelayed({
                returnAfterOrder()
            }, 2000) // Reduced from 3000ms
        }
    }

    private fun updateUIForOrderComplete(itemsText: String) {
        runOnUiThread {
            // Update UI to show confirmation using new container IDs
            binding.apply {
                tvTitle.text = "Order Confirmed! ✅"
                tvOrderNumber.text = "Order #$orderNumber"

                layoutChoiceButtons.visibility = android.view.View.GONE
                layoutQrCode.visibility = android.view.View.GONE
                webViewContainer.visibility = android.view.View.GONE
                completeOrderContainer.visibility = android.view.View.GONE
                btnBack.visibility = android.view.View.GONE

                // Show order summary
                val summaryText = """
                ✅ Order Confirmed!
                Order #$orderNumber
                
                $itemsText
                Total: RM $orderTotal
                
                Battery: ${currentBattery}%
                Thank you for your order!
            """.trimIndent()

                tvBattery.text = summaryText
            }
        }
    }

    private fun returnAfterOrder() {
        val finalOrderNumber = if (orderNumber != "Pending") orderNumber else "your order"
        // SHORTENED DIALOG: Much more concise return message
        speakAndWait("Order $finalOrderNumber is being prepared. Enjoy! Returning to base.") {

            // Release table if it's a takeaway order
            if (orderType.equals("Takeaway", ignoreCase = true)) {
                tableStatusManager.releaseTable(
                    sessionId = sessionId,
                    tableId = tableNo,
                    onSuccess = {
                        Log.d(TAG, "Table $tableNo released successfully")
                    },
                    onError = { error ->
                        Log.e(TAG, "Failed to release table: $error")
                    }
                )
            }

            returnToBase()
        }
    }

    private fun completeOrder() {
        resetInactivityTimer()

        if (!hasReceivedOrder) {
            speakAndWait("Please select items from the menu first, then use the order button in the menu.") {
                // Guide user back to menu
            }
            return
        }

        if (!isSpeaking) {
            showOrderConfirmation()
        } else {
            pendingOrderCompletion = true
        }
    }

    private fun proceedWithOrderCompletion() {
        showOrderConfirmation()
    }

    private fun handleBackPressed() {
        speakAndWait("Going back to table selection.") {
            finish()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        stopInactivityTimer()
        stopQRDisplayTimer()

        // CRITICAL: Proper WebView cleanup to prevent memory leaks
        try {
            binding.webView.apply {
                // Stop loading
                stopLoading()

                // Clear WebView
                clearHistory()
                clearCache(true)
                loadUrl("about:blank")

                // Remove JavaScript interface
                removeJavascriptInterface("Android")

                // Remove from parent
                (parent as? android.view.ViewGroup)?.removeView(this)

                // Destroy WebView
                destroy()
            }

            Log.d(TAG, "✅ WebView cleaned up properly")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error cleaning up WebView", e)
        }
    }

    override fun onBackPressed() {
        if (!isSpeaking) {
            handleBackPressed()
        } else {
            super.onBackPressed()
        }
    }

    // Handle user interactions to reset timer
    override fun onUserInteraction() {
        super.onUserInteraction()
        resetInactivityTimer()
    }
}